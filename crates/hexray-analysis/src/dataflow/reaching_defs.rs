//! Reaching definitions analysis.
//!
//! Reaching definitions computes, for each program point, which definitions
//! may reach that point without being killed by an intervening redefinition.
//!
//! This is a forward dataflow analysis where:
//! - Meet: union (a definition reaches if it reaches along any path)
//! - Transfer: gen âˆª (in - kill)

#![allow(dead_code)]

use super::{DataflowAnalysis, DataflowSolver, InstructionEffects, Location};
use hexray_core::{BasicBlockId, ControlFlowGraph};
use std::collections::{HashMap, HashSet};

/// A definition identifier: (block_id, instruction_index).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct DefinitionPoint {
    pub block: BasicBlockId,
    pub index: usize,
}

/// The dataflow fact: set of reaching definitions per location.
#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub struct ReachingDefsFact {
    /// Maps each location to the set of definitions that reach this point.
    pub reaching: HashMap<Location, HashSet<DefinitionPoint>>,
}

impl ReachingDefsFact {
    /// Returns true if a definition reaches this point.
    pub fn is_reaching(&self, loc: &Location, def: DefinitionPoint) -> bool {
        self.reaching
            .get(loc)
            .map(|defs| defs.contains(&def))
            .unwrap_or(false)
    }

    /// Returns all definitions of a location that reach this point.
    pub fn get(&self, loc: &Location) -> Option<&HashSet<DefinitionPoint>> {
        self.reaching.get(loc)
    }
}

/// Reaching definitions analysis.
pub struct ReachingDefinitions {
    /// Gen sets: definitions generated by each block.
    gen_sets: HashMap<BasicBlockId, HashMap<Location, DefinitionPoint>>,
    /// Kill sets: definitions killed by each block.
    kill_sets: HashMap<BasicBlockId, HashSet<Location>>,
    /// All definition points in the CFG.
    all_defs: HashMap<Location, HashSet<DefinitionPoint>>,
}

impl ReachingDefinitions {
    /// Creates a new reaching definitions analysis.
    pub fn new(cfg: &ControlFlowGraph) -> Self {
        let mut gen_sets: HashMap<BasicBlockId, HashMap<Location, DefinitionPoint>> = HashMap::new();
        let mut kill_sets: HashMap<BasicBlockId, HashSet<Location>> = HashMap::new();
        let mut all_defs: HashMap<Location, HashSet<DefinitionPoint>> = HashMap::new();

        // Compute gen and kill sets for each block
        for block in cfg.blocks() {
            let mut block_gen: HashMap<Location, DefinitionPoint> = HashMap::new();
            let mut block_kill: HashSet<Location> = HashSet::new();

            for (index, inst) in block.instructions.iter().enumerate() {
                let effects = InstructionEffects::from_instruction(inst);

                for loc in effects.defs {
                    let def_point = DefinitionPoint {
                        block: block.id,
                        index,
                    };

                    // This definition kills previous ones in this block
                    block_kill.insert(loc.clone());

                    // And generates this one
                    block_gen.insert(loc.clone(), def_point);

                    // Track all definitions
                    all_defs.entry(loc).or_default().insert(def_point);
                }
            }

            gen_sets.insert(block.id, block_gen);
            kill_sets.insert(block.id, block_kill);
        }

        Self { gen_sets, kill_sets, all_defs }
    }

    /// Runs the analysis and returns reaching definitions at each block.
    pub fn analyze(
        cfg: &ControlFlowGraph,
    ) -> HashMap<BasicBlockId, (ReachingDefsFact, ReachingDefsFact)> {
        let analysis = Self::new(cfg);
        DataflowSolver::solve_forward(&analysis, cfg)
    }

    /// Returns the reaching definitions at a specific instruction within a block.
    pub fn at_instruction(
        facts: &HashMap<BasicBlockId, (ReachingDefsFact, ReachingDefsFact)>,
        cfg: &ControlFlowGraph,
        block_id: BasicBlockId,
        inst_index: usize,
    ) -> ReachingDefsFact {
        let block = match cfg.block(block_id) {
            Some(b) => b,
            None => return ReachingDefsFact::default(),
        };

        let (input, _) = match facts.get(&block_id) {
            Some(f) => f,
            None => return ReachingDefsFact::default(),
        };

        let mut current = input.clone();

        // Apply transfer function up to (but not including) the target instruction
        for (index, inst) in block.instructions.iter().enumerate() {
            if index >= inst_index {
                break;
            }

            let effects = InstructionEffects::from_instruction(inst);

            for loc in effects.defs {
                let def_point = DefinitionPoint {
                    block: block_id,
                    index,
                };
                // Kill old definitions and add new one
                current.reaching.insert(loc, HashSet::from([def_point]));
            }
        }

        current
    }
}

impl DataflowAnalysis for ReachingDefinitions {
    type Fact = ReachingDefsFact;

    fn initial_fact(&self) -> Self::Fact {
        ReachingDefsFact::default()
    }

    fn meet(&self, facts: Vec<&Self::Fact>) -> Self::Fact {
        // Union of all reaching definitions
        let mut result = ReachingDefsFact::default();

        for fact in facts {
            for (loc, defs) in &fact.reaching {
                result.reaching
                    .entry(loc.clone())
                    .or_default()
                    .extend(defs.iter().copied());
            }
        }

        result
    }

    fn transfer(
        &self,
        block_id: BasicBlockId,
        input: &Self::Fact,
        _cfg: &ControlFlowGraph,
    ) -> Self::Fact {
        let mut output = input.clone();

        let block_gen = self.gen_sets.get(&block_id);
        let block_kill = self.kill_sets.get(&block_id);

        // Apply kill: remove definitions of killed locations (but keep others)
        if let Some(killed) = block_kill {
            for loc in killed {
                // For each killed location, we'll replace with gen
                // So we remove all reaching defs for killed locations
                output.reaching.remove(loc);
            }
        }

        // Apply gen: add the last definition of each location in this block
        if let Some(generated) = block_gen {
            for (loc, def_point) in generated {
                output.reaching
                    .entry(loc.clone())
                    .or_default()
                    .insert(*def_point);
            }
        }

        output
    }

    fn is_forward(&self) -> bool {
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use hexray_core::{BasicBlock, ControlFlowGraph, Instruction, Operation, Operand, Register, RegisterClass, BlockTerminator, Architecture};

    fn make_mov(addr: u64, reg_id: u16, _reg_name: &str, value: i128) -> Instruction {
        let mut inst = Instruction::new(addr, 3, vec![0; 3], "mov");
        inst.operation = Operation::Move;
        inst.operands = vec![
            Operand::Register(Register::new(Architecture::X86_64, RegisterClass::General, reg_id, 64)),
            Operand::Immediate(hexray_core::Immediate { value, size: 8, signed: false }),
        ];
        inst
    }

    #[test]
    fn test_reaching_defs_linear() {
        // Linear block:
        // mov rax, 1  ; def rax
        // mov rbx, 2  ; def rbx
        // mov rax, 3  ; def rax (kills first)
        let mut cfg = ControlFlowGraph::new(BasicBlockId::new(0));
        let mut bb = BasicBlock::new(BasicBlockId::new(0), 0x1000);

        bb.push_instruction(make_mov(0x1000, 0, "rax", 1));
        bb.push_instruction(make_mov(0x1003, 1, "rbx", 2));
        bb.push_instruction(make_mov(0x1006, 0, "rax", 3));
        bb.terminator = BlockTerminator::Return;

        cfg.add_block(bb);

        let facts = ReachingDefinitions::analyze(&cfg);
        let (_, output) = &facts[&BasicBlockId::new(0)];

        // At exit: rax def at index 2, rbx def at index 1
        let rax_loc = Location::Register(0);
        let rbx_loc = Location::Register(1);

        assert!(output.reaching.get(&rax_loc).is_some());
        assert!(output.reaching.get(&rbx_loc).is_some());

        let rax_defs = output.reaching.get(&rax_loc).unwrap();
        assert_eq!(rax_defs.len(), 1);
        assert!(rax_defs.contains(&DefinitionPoint {
            block: BasicBlockId::new(0),
            index: 2,
        }));
    }

    #[test]
    fn test_reaching_defs_branch() {
        // if/else:
        //   bb0: mov rax, 1 -> bb1, bb2
        //   bb1: mov rax, 2 -> bb3
        //   bb2: (no rax def) -> bb3
        //   bb3: (join) - should have both defs from bb0 and bb1
        let mut cfg = ControlFlowGraph::new(BasicBlockId::new(0));

        let mut bb0 = BasicBlock::new(BasicBlockId::new(0), 0x1000);
        bb0.push_instruction(make_mov(0x1000, 0, "rax", 1));
        bb0.terminator = BlockTerminator::ConditionalBranch {
            condition: hexray_core::Condition::Equal,
            true_target: BasicBlockId::new(1),
            false_target: BasicBlockId::new(2),
        };
        cfg.add_block(bb0);

        let mut bb1 = BasicBlock::new(BasicBlockId::new(1), 0x1010);
        bb1.push_instruction(make_mov(0x1010, 0, "rax", 2));
        bb1.terminator = BlockTerminator::Jump {
            target: BasicBlockId::new(3),
        };
        cfg.add_block(bb1);

        let mut bb2 = BasicBlock::new(BasicBlockId::new(2), 0x1020);
        bb2.terminator = BlockTerminator::Jump {
            target: BasicBlockId::new(3),
        };
        cfg.add_block(bb2);

        let mut bb3 = BasicBlock::new(BasicBlockId::new(3), 0x1030);
        bb3.terminator = BlockTerminator::Return;
        cfg.add_block(bb3);

        cfg.add_edge(BasicBlockId::new(0), BasicBlockId::new(1));
        cfg.add_edge(BasicBlockId::new(0), BasicBlockId::new(2));
        cfg.add_edge(BasicBlockId::new(1), BasicBlockId::new(3));
        cfg.add_edge(BasicBlockId::new(2), BasicBlockId::new(3));

        let facts = ReachingDefinitions::analyze(&cfg);
        let (input, _) = &facts[&BasicBlockId::new(3)];

        let rax_loc = Location::Register(0);
        let rax_defs = input.reaching.get(&rax_loc).unwrap();

        // Should have both definitions reaching bb3
        assert_eq!(rax_defs.len(), 2);
    }
}
